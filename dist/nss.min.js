var L=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var Y=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var G=n=>L(n,"__esModule",{value:!0});var H=(n,e)=>{for(var t in e)L(n,t,{get:e[t],enumerable:!0})},Q=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of Y(e))!q.call(n,a)&&(t||a!=="default")&&L(n,a,{get:()=>e[a],enumerable:!(r=K(e,a))||r.enumerable});return n};var V=(n=>(e,t)=>n&&n.get(e)||(t=Q(G({}),e,1),n&&n.set(e,t),t))(typeof WeakMap!="undefined"?new WeakMap:0);var te={};H(te,{default:()=>j,isCondNSSObject:()=>R,resolveNSSArg:()=>z});var D={separator:"",elementSeparator:"",conditionalSeparator:"",caseSensitiveProps:!1},f={...D};function W(n){Object.assign(f,n===null?D:n)}function X(){return f.elementSeparator?.length?f.elementSeparator:f.separator?.length?f.separator:"-"}function Z(){return f.conditionalSeparator?.length?f.conditionalSeparator:f.separator?.length?f.separator+f.separator:"--"}function k(){throw new Error("Don't coerce to string directly; use .c (alias: .cls)")}function A(n){return n?.toString===k}function $(n){return A(n)&&n===n?.parent}function U(n){let{parent:e}=n;return $(e)&&!R(n)}function R(n){let{off:e}=n;return A(n)&&typeof e=="boolean"}function j(n,e,t,r){let a=X(),u=Z();if(n=_(n),e=_(e),t=_(t),typeof r=="function"){let s={};r=r(s)??s}let[l,O]=ne(n,r),b=Object.entries(r??[]),i=new Map(b),g=new Map(b.map(([s])=>[s.toLowerCase(),s]));l&&(i.set(l,O??null),g.set(l.toLowerCase(),l));function B([s,p]){let d=i.get(s);return d?!p||p===s?[s,d]:[s,p+" "+d]:(typeof p=="string"&&p.length?(i.set(s,p),g.set(s.toLowerCase(),s)):(i.set(s,null),g.set(s.toLowerCase(),s)),[s,p])}e=Object.fromEntries(Object.entries(e??{}).map(B)),t=Object.fromEntries(Object.entries(t??{}).map(B));function c(s,p,d){return Object.fromEntries(Object.entries(t??{}).map(([C,F])=>{let S=s?.length?s+" ":"",[h,I]=P(C,F);function N(J){let v,M;!arguments.length||J?(M=!1,v=S+p+C+I):(M=!0,v=s);let T={off:M,cls:v,c:v,name:C,value:p+C,mapped:h,toString:k,parent:d};return Object.assign(T,c(v,p,d)),T}return N.off=!1,N.cls=S+p+C+I,N.c=N.cls,N.value=p+C,N.mapped=h,N.toString=k,N.parent=d,Object.defineProperty(N,"name",{value:C,writable:!1}),[C,N]}))}let E=Object.fromEntries(Object.entries(e??{}).map(([s,p])=>{let d=(l?l+a:"")+s,[C,F]=P(s,p);function S(...h){return x({name:s,cls:d,separator:u,base:o,builder:S,mapped:C,mappings:i,mappingsLowercase:g,values:h,caseSensitive:!0,strictBoolChecks:!1,acceptArbitraryStrings:!0})}return S.cls=d+F,S.c=S.cls,S.value=d,S.mapped=C,S.toString=k,S.parent=o,S.props=function(...h){return x({name:s,cls:d,separator:u,base:o,builder:S,mapped:C,mappings:i,mappingsLowercase:g,values:h,caseSensitive:f.caseSensitiveProps,strictBoolChecks:!0,acceptArbitraryStrings:!1})},Object.assign(S,c(S.c,d+u,S)),Object.defineProperty(S,"name",{value:s,writable:!1}),[s,S]})),m=l??"",[y,w]=P(l,O);function o(...s){return x({name:m,cls:m,separator:u,base:o,builder:o,mapped:y,mappings:i,mappingsLowercase:g,values:s,caseSensitive:!0,strictBoolChecks:!1,acceptArbitraryStrings:!0})}return o.cls=m+w,o.c=o.cls,o.value=m,o.mapped=y,o.toString=k,o.parent=o,o.props=function(...s){return x({name:m,cls:m,separator:u,base:o,builder:o,mapped:y,mappings:i,mappingsLowercase:g,values:s,caseSensitive:f.caseSensitiveProps,strictBoolChecks:!0,acceptArbitraryStrings:!1})},Object.defineProperty(o,"name",{value:l,writable:!1}),l&&Object.defineProperty(o,l,{value:o,writable:!1}),Object.assign(o,E),Object.assign(o,c(o.c,l?l+u:"",o)),o}function z(n,e){if(A(e)){let t=n[e.name],r=t;if(!t)r=e;else if(e.off)return"";let{cls:a,mapped:u}=r;return a.slice(a.lastIndexOf(" ",a.length-(u?.length??0)-2)+1)}else return null}function x({name:n,cls:e,separator:t,base:r,builder:a,mapped:u,mappings:l,mappingsLowercase:O,values:b,caseSensitive:i,strictBoolChecks:g,acceptArbitraryStrings:B}){if(!i&&l.size!=O.size){let y=Array.from(l.keys()),w=[];Array.from(l.keys()).find(s=>(w=y.filter(p=>p.toLowerCase()===s.toLowerCase()),w.length>1));let o=w.length?w.map(s=>`"${s}"`).join(", ")+" ":"";throw new Error(`You're using multiple class names ${o}that are identical apart from casing; this causes ambiguity when using .props(...)`)}let c,E=u??"";if(b.length){let y=ee({builder:a,mappings:l,mappingsLowercase:O,prefix:e+(e.length?t:""),values:b,caseSensitive:i,strictBoolChecks:g,acceptArbitraryStrings:B});c=E.length&&y.length?" ":"",E+=c+y}return c=e.length&&E.length&&E[0]!==" "?" ":"",{__nss__:!0,name:n,cls:e+c+E,c:e+c+E,value:e,mapped:u,toString:k,parent:r}}function ee({builder:n,mappings:e,mappingsLowercase:t,prefix:r,values:a,caseSensitive:u,strictBoolChecks:l,acceptArbitraryStrings:O}){let b="";for(let i of a){if(typeof i=="string"||i instanceof String)throw new Error("Do not pass strings directly; enclose in object or array");if(i){let g=z(n,i);if(g!==null)b+=g?.length?" "+g:"";else{let B;if(Array.isArray(i))B=i.map(c=>[c,!0]);else{try{B=Object.entries(i)}catch{B=null}if(!B?.length)throw new Error(`NSS Error: Invalid input ${JSON.stringify(i)}.`)}for(let[c,E]of B)if(E===!0||!l&&E){if(!O){if(u){if(!e.has(c))continue}else if(!t.has(c.toLowerCase()))continue}u?b+=" "+r+c:b+=" "+r+t.get(c.toLowerCase());let m=u?e.get(c):e.get(t.get(c.toLowerCase()));m?.length&&(typeof m=="string"||m instanceof String)&&(b+=" "+m)}}}}return b.slice(1)}function _(n){return n&&Object.fromEntries(Object.entries(n).filter(([e])=>!Number.isInteger(Number(e))).map(([e,t])=>[e,Number.isInteger(Number(t))?null:t]))}function ne(n,e){let t=null,r=null;if(n&&typeof n=="object"){let a=Object.entries(n);if(a.length>1)throw new Error("NSS Error: Invalid name enum provided; should have at most 1 field.");a.length===1&&([[t,r]]=a)}if(t&&e&&typeof e=="object"){let a=Object.prototype.hasOwnProperty.call(e,t)&&e[t];a&&(r=(r?r+" ":"")+a)}return[t,r]}function P(n,e){let t=e??"",r=t.length&&t!==n,a=r?t:null,u=r?" "+t:"";return[a,u]}j.config=f;j.configure=W;j.isInstance=A;j.isBase=$;j.isElem=U;j.isCond=R;module.exports=V(te);
